Sounds like the repo still tracks a filename that contains invisible / unprintable bytes so you can't reference it normally. You can remove the tracked file from Git (without needing a working-copy file) by operating on the index directly. Below are safe, practical ways to find the exact name and remove it from the index. Start with the dry-run steps and only run the actual remove when you're sure.

Summary of approach

Find the exact filename (showing non‑printable bytes).
Use git to remove that path from the index (without needing the file on disk) using a pathspec file or a literal NUL‑terminated path so Git receives the exact byte sequence.
Commit the removal.
Inspect tracked filenames and show non-printables Run this to list tracked files and make non-printable bytes visible (POSIX shell / Linux / macOS):
Show with escapes (makes invisible bytes visible): git ls-files -z | tr '\0' '\n' | cat -v

Show hex bytes for each filename (helpful if you need to craft escape sequences): git ls-files -z | xargs -0 -I{} bash -c 'printf "%s -> " "$1"; printf "%s\n" "$1" | od -An -t x1' -- {}

Look through that output for the problematic entry (you can search by a visible substring if present).

Safe dry-run removal using a pathspec file (POSIX) This method builds a NUL-separated list of paths and tells git rm to remove them from the index. It avoids needing the shell to correctly interpret invisible characters.
If you can match the file by a substring (recommended): git ls-files -z | grep -z -F 'part_of_name' > /tmp/badpaths # NUL-separated matches

Dry-run: show what would be removed from the index
git rm --cached --ignore-unmatch --dry-run --pathspec-from-file=/tmp/badpaths --pathspec-file-nul

If the dry-run looks correct, actually remove from the index: git rm --cached --ignore-unmatch --pathspec-from-file=/tmp/badpaths --pathspec-file-nul git commit -m "Remove tracked file with problematic (unprintable) filename"

Notes:

--ignore-unmatch prevents errors if something changed meanwhile.
--pathspec-file-nul tells Git the file is NUL‑terminated (matches how git ls-files -z outputs).
You can remove the temporary file afterward: rm /tmp/badpaths
If you can’t match a substring — create a path file by copying the literal name If you saw the exact printed line from step (1), you can craft a file containing that exact filename (NUL-terminated). Example in a bash shell, where you copy the displayed filename exactly into the printf:
printf '%s\0' 'PASTE_EXACT_FILENAME_HERE' > /tmp/badpaths

Dry-run:
git rm --cached --ignore-unmatch --dry-run --pathspec-from-file=/tmp/badpaths --pathspec-file-nul

Remove:
git rm --cached --ignore-unmatch --pathspec-from-file=/tmp/badpaths --pathspec-file-nul git commit -m "Remove tracked file with problematic filename"

If the filename contains bytes you can’t paste, build the NUL file from hex using printf with \x escapes (you can use the hex output from the od command earlier to build the \xHH sequence).

Simple alternative: stage deletion of all removed files If you deleted the file from your working tree and just want to stage all deletions and commit:
git add -u # stage modifications and deletions (updates index) git commit -m "Remove deleted files" # commit index state

This will stage the deletion if Git can match the path in the index. If the filename is unprintable and Git can't match via your shell quoting, use pathspec-from-file method above.

Windows / PowerShell users In PowerShell you can create a pathspec file with literal content and pass it to Git similarly. For example, to remove by substring:
git ls-files | Select-String -Pattern 'part_of_name' | ForEach-Object { $_.Line } | Out-File -Encoding ASCII .\badpaths.txt git rm --cached --ignore-unmatch --pathspec-from-file=badpaths.txt git commit -m "Remove problematic file"

If the filename is not representable in your console, inspect it from Git Bash or WSL (which handle arbitrary bytes better) and use the POSIX method above.

If you still can’t remove it
Show me the output of: git ls-files -z | tr '\0' '\n' | nl -ba | sed -n '1,200p' (paste the offending line(s) here). If you prefer, paste the output from the hex inspector: git ls-files -z | xargs -0 -I{} bash -c 'printf "%s -> " "$1"; printf "%s\n" "$1" | od -An -t x1' -- {}
I can then tell you the exact printf or \x escape sequence to build the NUL pathspec file to remove it safely.

Safety tips
Always dry-run first (git rm --dry-run or inspect the /tmp/badpaths file).
If you have uncommitted local work, stash it (git stash) before doing index edits.
If unsure, make a branch (git checkout -b fix-bad-name) before committing removals so you can easily revert.
If you tell me:

which OS / shell you’re using (Linux, macOS, Git Bash, Windows PowerShell),
and paste the output of the hex inspector command (from step 1), or the visible line from git ls-files -z shown with cat -v, I’ll build the exact command you should run to remove the tracked entry and show the exact printf sequence to create the pathspec file.